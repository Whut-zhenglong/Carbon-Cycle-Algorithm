function y = fitnessfunction(x)
%   判断线段与多边形某一条边是否相交，相交返回路径距离为100000，不相交返回两点欧式距离

%   输出 distance ：整条路径距离

%   输入 postion1  ：路径第i个坐标点的坐标[x11,y11]
%   输入 postion2  ：路径第i+1个坐标点的坐标点[x12,y12]
%   输入 postion1  ：多边形某边第i个坐标点的坐标[x21,y21]
%   输入 postion2  ：多边形某边第i+1个坐标点的坐标点[x22,y22]
% x=[0,-0.23,-4.8,-4.8,-4.8,-4.8,-4.8,-4.8,-4.8,-4.8,-4.8,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,5,-5,-5,-5,0];
% x=[0,-3,-4.8,-4.8,-4.8,-4.8,-4.8,-4.8,-4.8,-4.8,-4.8,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,5,-5,-5,-5,0];
pointx=[0,0.887200000000000,1.77430000000000,2.66150000000000,3.54860000000000,4.43580000000000,5.32290000000000,6.21010000000000,7.09720000000000,7.98440000000000,8.87150000000000,9.75870000000000,10.6458000000000,11.5330000000000,12.4202000000000,13.3073000000000,14.1945000000000,15.0816000000000,15.9688000000000,16.8559000000000,17.7431000000000,18.6302000000000,19.5174000000000,20.4045000000000,21.2917000000000,22.1788000000000,23.0660000000000,23.9532000000000,24.8403000000000,25.7275000000000,26.6146000000000,27.5018000000000,28.3889000000000,29.2761000000000,30.1632000000000,31.0504000000000,31.9375000000000,32.8247000000000,33.7118000000000,34.5990000000000];
pointy = [0,x,0];
% postion3,postion4
load obstacle_new
for  k= 1:length(pointx)-1
    postion1 = [pointx(k),pointy(k)];
    postion2 = [pointx(k+1),pointy(k+1)];

% postion1 = [0,4];%碰撞
% % postion1 = [0,10];%不碰撞
% postion2 = [3.84,8];

% %相交测试算例
% postion1 = [12.04,9.67];
% postion2 = [46.59,7.83];
% postion3 = [30.44,8.95];
% postion4 = [31.53,8.41];
% %不相交测试算例
% postion1 = [12.04,9.67];
% postion2 = [46.59,7.83];
% postion3 = [15.92,10.49];
% postion4 = [18.34,11.03];
    for i = 1:length(obstacle_new)
        obstacle_temp{i,1} = [obstacle_new{i,1},obstacle_new{i,1}(:,1)];
        for j =1:length(obstacle_new{i,1})
            postion3 = [obstacle_temp{i,1}(1,j),obstacle_temp{i,1}(2,j)];
            postion4 = [obstacle_temp{i,1}(1,j+1),obstacle_temp{i,1}(2,j+1)];
            %% 将两条线段平移，将AB左端点平移至原点
            x11 = postion1(1,1);
            y11 = postion1(1,2);
            x12 = postion2(1,1);
            y12 = postion2(1,2);
            x21 = postion3(1,1);
            y21 = postion3(1,2);
            x22 = postion4(1,1);
            y22 = postion4(1,2);

            %得到平移后的新的坐标点
            X11 = 0;
            Y11 = 0;
            X12 = x12 - x11;
            Y12 = y12 - y11;
            X21 = x21 - x11;
            Y21 = y21 - y11;
            X22 = x22 - x11;
            Y22 = y22 - y11; 


            %% 将两条线段旋转，逆时针旋转为正；顺时针旋转为正

            %旋转角度求解
            tha = atan2(Y12,X12);
            %坐标旋转矩阵
            A = [cos(tha),sin(tha);-sin(tha),cos(tha)];
            %旋转后的新坐标
            postion2_new = A*[X12;Y12];
            postion3_new = A*[X21;Y21];
            postion4_new = A*[X22;Y22];
            X12 = postion2_new(1,1);
            Y12 = postion2_new(2,1);
            X21 = postion3_new(1,1);
            Y21 = postion3_new(2,1);
            X22 = postion4_new(1,1);
            Y22 = postion4_new(2,1);

            %% 判断是否两条线相交 相交条件：1.线段2两个端点纵坐标异号；2.直线交点的位置
            collision(i,j) = 0;
    %         distance = sqrt(X12^2 + Y12 ^2);
            if Y21 * Y22 < 0  % 与X轴平行时  坐标为0判断
                PX = X22 + (X21 - X22) * Y22 / (Y22 - Y21);
                if PX > 0 && PX < X12   
    %                 distance = 100000;
                    collision(i,j) = 1;
                end
            end
        end
    end

%     if  sum(sum(collision)) == 0
%         fprintf("不碰撞\n") ;
%         distance(k) = sqrt(X12^2 + Y12 ^2); 
%     else
%         fprintf("碰撞\n");
%         distance(k) = 100000;
% %         break
            
   %% 计算路线与障碍物相交的数量，给一个惩罚值
   safe_value(k) = sum(sum(collision));
            
   %% 计算该条路线的实际距离
   distance(k) = sqrt(X12^2 + Y12 ^2);         
end
distance_all = sum(distance);
safe_all = sum(safe_value)*1000;
y=distance_all+safe_all;
end


